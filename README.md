RAPIDA 0.0.3 ecommerce CMS SimplaCMS 2.3.8 fork

****************
Changelog
****************



=================
v0.0.4 13.10.2017
=================
- Изменен метод db->results(string $field = null, string $group_field = null), теперь он работает аналогично, results_array с той разницей, что выдает массив с объектами внутри, а не массив с массивами внутри.
= Добавлены файлы для выполнения очереди задач через cron. Выполнить задания из очереди cron/queue_exec.php. Посмотреть кол-во заданий в очереди cron/queue_count.php
- Добавлен метод db->results_object(string $group_field = null) и изменен db->results_array(string $group_field = null). Работают сходным образом, с той разницей, что один выдает объект, а второй массив.
- На метод products->get_products() прикручен дисковый кеш через методы cache->set_cache_nosql() cache->get_cache_nosql(). Кеш пишет на диск вывод метода products->get_products в виде json строки, а при чтении из кеша, преобразует json строку обратно в объект.
- Мелким изменениям подверглись почти все файлы view/*.php и simpla/*.php в связи с использованием в методе products->get_products() нового метода db->results_object(). Пришлось изменить на новый метод в связи с тем, что дисковый кеш cache->set_cache_nosql() и cache->get_cache_nosql() используют для записи на диск функции json_decode json_encode, которые все пишут в объект. В результате при обратном преобразовании ф-цией json_decode данных из кеша с диска невозможно было восстановить, объекты, как объекты, а массивы, как массивы. Теперь все данные выводятся чистыми объектами.
- Внесены изменения в методы products->get_products() и products->get_related_products(), теперь результат выполнения сразу группируется по id, соответствующие изменения внесены во всех случаях использования этих методов.
- Изменен метод 'products->add_image()'. Оптимизирована работа. Кол-во запросов уменьшено до 2. Первый запрос определяет максимальную позицию изображений товара, 2 запрос добавляет новое изображение товара, сразу устанавливая позицию макс. знач. + 1.
- Исправлена ошибка в simpla/ProductAdmin.php message_error добавляется в шаблон в любом случае, если ошибки нет - добавляется пустой message_error.
- В файле simpla/index.php удалены указания на несуществующий дебагер, добавлен дебагер dtimer::show(), также как в файле /index.php
- в методе request->url иправлена ошибка. Если при парсинге адресной строки через $url = parse_url($_SERVER['REQUEST_URI']) в полученном массиве нет элемента 'query' (часть после ?) $url['query'] - вылетала ошибка. Теперь добавлена предварительная проверка и ошибка больше не вылетает.

=================
v0.0.3 13.10.2017
=================
- Добавлен метод в класс db public function results_array(string $field = null, string $group_field = null). Основная фишка - поле группировки, позволяет избежать двойной работы, когда сначала в методе db->results происходит перебор и запись строк в объект, а потом, например, во view/ProductsView.php происходит перебор: 
		foreach($this->products->get_products($filter) as $p)
			$products[$p->id] = $p;
только, чтобы записать id товаров в виде ключей массива. $this->db->results_array(null, 'id') выдаст результат в виде массива с ключами из поля id.

=================
v0.0.2 12.10.2017
=================
- Добавлен отладчик ошибок dtimer в виде отдельной библиотеки api/Dtimer.php
- В config.ini выведена опция dtimer_disabled для включения/выпключения отладчика. Когда опция true, вызовы метода отладчика на запись dtimer::log('info') и на вывод журнала отладчика dtimer::show() не срабатывает и не забивает память. dtimer_disabled = false включает запись событий в отладчик, а также включает отображение журнала. Вызов происходит из файла index.php. Отладчик записывает текстовую строку, а также время записи этой строки в журнал отладчика.
- Добавлена библиотека кеширования cache api/Cache.php и библиотека очереди queue api/Queue.php. Пока используется для кеширования только одного метода product->count_products(). Механизм работы. При обращении к методу по входным параметрам в массиве $filter формируется md4 hash, который через метод cache->get_cache_integer() ищет в базе сохраненный кеш, если кеш не найден, происходит полное выполнение метода count_products(), в конце перед return происходит запись в кеш через метод cache->set_cache_integer(). Очередь заданий queue используется следующим образом. метод queue->addtask($keyhash, 'name', $task); пишет в очередь заданий задачу на выполнение count_products() без использования кеша с последующим обновлением результата в кеше. За счет этого кеш постоянно обновляется, но обновление происходит в отдельном процессе вызываемом планировщиком cron, т.е. для пользователя функция выполняется быстро, а сложная работа протекает на фоне.

